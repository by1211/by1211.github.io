(function() {
  var UnicodeTrie, UnicodeTrieBuilder, assert;

  assert = require('assert');

  UnicodeTrieBuilder = require('../builder');

  UnicodeTrie = require('../');

  describe('unicode trie', function() {
    var rangeTests;
    it('set', function() {
      var trie;
      trie = new UnicodeTrieBuilder(10, 666);
      trie.set(0x4567, 99);
      assert.equal(trie.get(0x4566), 10);
      assert.equal(trie.get(0x4567), 99);
      assert.equal(trie.get(-1), 666);
      return assert.equal(trie.get(0x110000), 666);
    });
    it('set -> compacted trie', function() {
      var t, trie;
      t = new UnicodeTrieBuilder(10, 666);
      t.set(0x4567, 99);
      trie = t.freeze();
      assert.equal(trie.get(0x4566), 10);
      assert.equal(trie.get(0x4567), 99);
      assert.equal(trie.get(-1), 666);
      return assert.equal(trie.get(0x110000), 666);
    });
    it('setRange', function() {
      var trie;
      trie = new UnicodeTrieBuilder(10, 666);
      trie.setRange(13, 6666, 7788, false);
      trie.setRange(6000, 7000, 9900, true);
      assert.equal(trie.get(12), 10);
      assert.equal(trie.get(13), 7788);
      assert.equal(trie.get(5999), 7788);
      assert.equal(trie.get(6000), 9900);
      assert.equal(trie.get(7000), 9900);
      assert.equal(trie.get(7001), 10);
      return assert.equal(trie.get(0x110000), 666);
    });
    it('setRange -> compacted trie', function() {
      var t, trie;
      t = new UnicodeTrieBuilder(10, 666);
      t.setRange(13, 6666, 7788, false);
      t.setRange(6000, 7000, 9900, true);
      trie = t.freeze();
      assert.equal(trie.get(12), 10);
      assert.equal(trie.get(13), 7788);
      assert.equal(trie.get(5999), 7788);
      assert.equal(trie.get(6000), 9900);
      assert.equal(trie.get(7000), 9900);
      assert.equal(trie.get(7001), 10);
      return assert.equal(trie.get(0x110000), 666);
    });
    it('should work with compressed serialization format', function() {
      var buf, t, trie;
      t = new UnicodeTrieBuilder(10, 666);
      t.setRange(13, 6666, 7788, false);
      t.setRange(6000, 7000, 9900, true);
      buf = t.toBuffer();
      trie = new UnicodeTrie(buf);
      assert.equal(trie.get(12), 10);
      assert.equal(trie.get(13), 7788);
      assert.equal(trie.get(5999), 7788);
      assert.equal(trie.get(6000), 9900);
      assert.equal(trie.get(7000), 9900);
      assert.equal(trie.get(7001), 10);
      return assert.equal(trie.get(0x110000), 666);
    });
    rangeTests = [
      {
        ranges: [[0, 0, 0, 0], [0, 0x40, 0, 0], [0x40, 0xe7, 0x1234, 0], [0xe7, 0x3400, 0, 0], [0x3400, 0x9fa6, 0x6162, 0], [0x9fa6, 0xda9e, 0x3132, 0], [0xdada, 0xeeee, 0x87ff, 0], [0xeeee, 0x11111, 1, 0], [0x11111, 0x44444, 0x6162, 0], [0x44444, 0x60003, 0, 0], [0xf0003, 0xf0004, 0xf, 0], [0xf0004, 0xf0006, 0x10, 0], [0xf0006, 0xf0007, 0x11, 0], [0xf0007, 0xf0040, 0x12, 0], [0xf0040, 0x110000, 0, 0]],
        check: [[0, 0], [0x40, 0], [0xe7, 0x1234], [0x3400, 0], [0x9fa6, 0x6162], [0xda9e, 0x3132], [0xdada, 0], [0xeeee, 0x87ff], [0x11111, 1], [0x44444, 0x6162], [0xf0003, 0], [0xf0004, 0xf], [0xf0006, 0x10], [0xf0007, 0x11], [0xf0040, 0x12], [0x110000, 0]]
      }, {
        ranges: [[0, 0, 0, 0], [0x21, 0x7f, 0x5555, 1], [0x2f800, 0x2fedc, 0x7a, 1], [0x72, 0xdd, 3, 1], [0xdd, 0xde, 4, 0], [0x201, 0x240, 6, 1], [0x241, 0x280, 6, 1], [0x281, 0x2c0, 6, 1], [0x2f987, 0x2fa98, 5, 1], [0x2f777, 0x2f883, 0, 1], [0x2f900, 0x2ffaa, 1, 0], [0x2ffaa, 0x2ffab, 2, 1], [0x2ffbb, 0x2ffc0, 7, 1]],
        check: [[0, 0], [0x21, 0], [0x72, 0x5555], [0xdd, 3], [0xde, 4], [0x201, 0], [0x240, 6], [0x241, 0], [0x280, 6], [0x281, 0], [0x2c0, 6], [0x2f883, 0], [0x2f987, 0x7a], [0x2fa98, 5], [0x2fedc, 0x7a], [0x2ffaa, 1], [0x2ffab, 2], [0x2ffbb, 0], [0x2ffc0, 7], [0x110000, 0]]
      }, {
        ranges: [[0, 0, 9, 0], [0x31, 0xa4, 1, 0], [0x3400, 0x6789, 2, 0], [0x8000, 0x89ab, 9, 1], [0x9000, 0xa000, 4, 1], [0xabcd, 0xbcde, 3, 1], [0x55555, 0x110000, 6, 1], [0xcccc, 0x55555, 6, 1]],
        check: [[0, 9], [0x31, 9], [0xa4, 1], [0x3400, 9], [0x6789, 2], [0x9000, 9], [0xa000, 4], [0xabcd, 9], [0xbcde, 3], [0xcccc, 9], [0x110000, 6]]
      }, {
        ranges: [[0, 0, 3, 0]],
        check: [[0, 3], [0x110000, 3]]
      }, {
        ranges: [[0, 0, 3, 0], [0, 0x110000, 5, 1]],
        check: [[0, 3], [0x110000, 5]]
      }
    ];
    return it('should pass range tests', function() {
      var check, errorValue, frozen, i, initialValue, j, k, len, len1, range, ref, results, start, test, trie;
      results = [];
      for (j = 0, len = rangeTests.length; j < len; j++) {
        test = rangeTests[j];
        initialValue = 0;
        errorValue = 0x0bad;
        i = 0;
        if (test.ranges[i][1] < 0) {
          errorValue = test.ranges[i][2];
          i++;
        }
        initialValue = test.ranges[i++][2];
        trie = new UnicodeTrieBuilder(initialValue, errorValue);
        ref = test.ranges.slice(i);
        for (k = 0, len1 = ref.length; k < len1; k++) {
          range = ref[k];
          trie.setRange(range[0], range[1] - 1, range[2], range[3] !== 0);
        }
        frozen = trie.freeze();
        start = 0;
        results.push((function() {
          var l, len2, ref1, results1;
          ref1 = test.check;
          results1 = [];
          for (l = 0, len2 = ref1.length; l < len2; l++) {
            check = ref1[l];
            results1.push((function() {
              var m, ref2, ref3, results2;
              results2 = [];
              for (start = m = ref2 = start, ref3 = check[0]; m < ref3; start = m += 1) {
                assert.equal(trie.get(start), check[1]);
                results2.push(assert.equal(frozen.get(start), check[1]));
              }
              return results2;
            })());
          }
          return results1;
        })());
      }
      return results;
    });
  });

}).call(this);
